{"ast":null,"code":"import _slicedToArray from \"/home/ductran/guide-rest-client-reactjs/start/src/main/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport * as React from 'react';\nexport function useOpenState(_ref) {\n  var open = _ref.open,\n      onOpen = _ref.onOpen,\n      onClose = _ref.onClose;\n  var isControllingOpenProp = React.useRef(typeof open === 'boolean').current;\n\n  var _React$useState = React.useState(false),\n      _React$useState2 = _slicedToArray(_React$useState, 2),\n      openState = _React$useState2[0],\n      setIsOpenState = _React$useState2[1]; // It is required to update inner state in useEffect in order to avoid situation when\n  // Our component is not mounted yet, but `open` state is set to `true` (e.g. initially opened)\n\n\n  React.useEffect(function () {\n    if (isControllingOpenProp) {\n      if (typeof open !== 'boolean') {\n        throw new Error('You must not mix controlling and uncontrolled mode for `open` prop');\n      }\n\n      setIsOpenState(open);\n    }\n  }, [isControllingOpenProp, open]);\n  var setIsOpen = React.useCallback(function (newIsOpen) {\n    if (!isControllingOpenProp) {\n      setIsOpenState(newIsOpen);\n    }\n\n    if (newIsOpen && onOpen) {\n      onOpen();\n    }\n\n    if (!newIsOpen && onClose) {\n      onClose();\n    }\n  }, [isControllingOpenProp, onOpen, onClose]);\n  return {\n    isOpen: openState,\n    setIsOpen: setIsOpen\n  };\n}\nexport default useOpenState;","map":{"version":3,"sources":["/home/ductran/guide-rest-client-reactjs/start/src/main/frontend/node_modules/@mui/lab/internal/pickers/hooks/useOpenState.js"],"names":["React","useOpenState","open","onOpen","onClose","isControllingOpenProp","useRef","current","useState","openState","setIsOpenState","useEffect","Error","setIsOpen","useCallback","newIsOpen","isOpen"],"mappings":";AAAA,OAAO,KAAKA,KAAZ,MAAuB,OAAvB;AACA,OAAO,SAASC,YAAT,OAIJ;AAAA,MAHDC,IAGC,QAHDA,IAGC;AAAA,MAFDC,MAEC,QAFDA,MAEC;AAAA,MADDC,OACC,QADDA,OACC;AACD,MAAMC,qBAAqB,GAAGL,KAAK,CAACM,MAAN,CAAa,OAAOJ,IAAP,KAAgB,SAA7B,EAAwCK,OAAtE;;AACA,wBAAoCP,KAAK,CAACQ,QAAN,CAAe,KAAf,CAApC;AAAA;AAAA,MAAOC,SAAP;AAAA,MAAkBC,cAAlB,uBAFC,CAE0D;AAC3D;;;AAEAV,EAAAA,KAAK,CAACW,SAAN,CAAgB,YAAM;AACpB,QAAIN,qBAAJ,EAA2B;AACzB,UAAI,OAAOH,IAAP,KAAgB,SAApB,EAA+B;AAC7B,cAAM,IAAIU,KAAJ,CAAU,oEAAV,CAAN;AACD;;AAEDF,MAAAA,cAAc,CAACR,IAAD,CAAd;AACD;AACF,GARD,EAQG,CAACG,qBAAD,EAAwBH,IAAxB,CARH;AASA,MAAMW,SAAS,GAAGb,KAAK,CAACc,WAAN,CAAkB,UAAAC,SAAS,EAAI;AAC/C,QAAI,CAACV,qBAAL,EAA4B;AAC1BK,MAAAA,cAAc,CAACK,SAAD,CAAd;AACD;;AAED,QAAIA,SAAS,IAAIZ,MAAjB,EAAyB;AACvBA,MAAAA,MAAM;AACP;;AAED,QAAI,CAACY,SAAD,IAAcX,OAAlB,EAA2B;AACzBA,MAAAA,OAAO;AACR;AACF,GAZiB,EAYf,CAACC,qBAAD,EAAwBF,MAAxB,EAAgCC,OAAhC,CAZe,CAAlB;AAaA,SAAO;AACLY,IAAAA,MAAM,EAAEP,SADH;AAELI,IAAAA,SAAS,EAATA;AAFK,GAAP;AAID;AACD,eAAeZ,YAAf","sourcesContent":["import * as React from 'react';\nexport function useOpenState({\n  open,\n  onOpen,\n  onClose\n}) {\n  const isControllingOpenProp = React.useRef(typeof open === 'boolean').current;\n  const [openState, setIsOpenState] = React.useState(false); // It is required to update inner state in useEffect in order to avoid situation when\n  // Our component is not mounted yet, but `open` state is set to `true` (e.g. initially opened)\n\n  React.useEffect(() => {\n    if (isControllingOpenProp) {\n      if (typeof open !== 'boolean') {\n        throw new Error('You must not mix controlling and uncontrolled mode for `open` prop');\n      }\n\n      setIsOpenState(open);\n    }\n  }, [isControllingOpenProp, open]);\n  const setIsOpen = React.useCallback(newIsOpen => {\n    if (!isControllingOpenProp) {\n      setIsOpenState(newIsOpen);\n    }\n\n    if (newIsOpen && onOpen) {\n      onOpen();\n    }\n\n    if (!newIsOpen && onClose) {\n      onClose();\n    }\n  }, [isControllingOpenProp, onOpen, onClose]);\n  return {\n    isOpen: openState,\n    setIsOpen\n  };\n}\nexport default useOpenState;"]},"metadata":{},"sourceType":"module"}