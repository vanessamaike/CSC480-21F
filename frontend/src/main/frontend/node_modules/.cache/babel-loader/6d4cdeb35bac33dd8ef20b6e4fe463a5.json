{"ast":null,"code":"import _slicedToArray from \"/home/ductran/guide-rest-client-reactjs/start/src/main/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport { useReducer, useRef, useLayoutEffect, useEffect } from 'react';\n\nvar useRifm = function useRifm(props) {\n  var _useReducer = useReducer(function (c) {\n    return c + 1;\n  }, 0),\n      _useReducer2 = _slicedToArray(_useReducer, 2),\n      refresh = _useReducer2[1];\n\n  var valueRef = useRef(null);\n  var replace = props.replace,\n      append = props.append;\n  var userValue = replace ? replace(props.format(props.value)) : props.format(props.value); // state of delete button see comments below about inputType support\n\n  var isDeleleteButtonDownRef = useRef(false);\n\n  var onChange = function onChange(evt) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (evt.target.type === 'number') {\n        console.error('Rifm does not support input type=number, use type=tel instead.');\n        return;\n      }\n\n      if (evt.target.type === 'date') {\n        console.error('Rifm does not support input type=date.');\n        return;\n      }\n    }\n\n    var eventValue = evt.target.value;\n    valueRef.current = [eventValue, // eventValue\n    evt.target, // input\n    eventValue.length > userValue.length, // isSizeIncreaseOperation\n    isDeleleteButtonDownRef.current, // isDeleleteButtonDown\n    userValue === props.format(eventValue) // isNoOperation\n    ];\n\n    if (process.env.NODE_ENV !== 'production') {\n      var formattedEventValue = props.format(eventValue);\n\n      if (eventValue !== formattedEventValue && eventValue.toLowerCase() === formattedEventValue.toLowerCase()) {\n        console.warn('Case enforcement does not work with format. Please use replace={value => value.toLowerCase()} instead');\n      }\n    } // The main trick is to update underlying input with non formatted value (= eventValue)\n    // that allows us to calculate right cursor position after formatting (see getCursorPosition)\n    // then we format new value and call props.onChange with masked/formatted value\n    // and finally we are able to set cursor position into right place\n\n\n    refresh();\n  }; // React prints warn on server in non production mode about useLayoutEffect usage\n  // in both cases it's noop\n\n\n  if (process.env.NODE_ENV === 'production' || typeof window !== 'undefined') {\n    useLayoutEffect(function () {\n      if (valueRef.current == null) return;\n\n      var _valueRef$current = _slicedToArray(valueRef.current, 5),\n          eventValue = _valueRef$current[0],\n          input = _valueRef$current[1],\n          isSizeIncreaseOperation = _valueRef$current[2],\n          isDeleleteButtonDown = _valueRef$current[3],\n          // No operation means that value itself hasn't been changed, BTW cursor, selection etc can be changed\n      isNoOperation = _valueRef$current[4];\n\n      valueRef.current = null; // this usually occurs on deleting special symbols like ' here 123'123.00\n      // in case of isDeleleteButtonDown cursor should move differently vs backspace\n\n      var deleteWasNoOp = isDeleleteButtonDown && isNoOperation;\n      var valueAfterSelectionStart = eventValue.slice(input.selectionStart);\n      var acceptedCharIndexAfterDelete = valueAfterSelectionStart.search(props.accept || /\\d/g);\n      var charsToSkipAfterDelete = acceptedCharIndexAfterDelete !== -1 ? acceptedCharIndexAfterDelete : 0; // Create string from only accepted symbols\n\n      var clean = function clean(str) {\n        return (str.match(props.accept || /\\d/g) || []).join('');\n      };\n\n      var valueBeforeSelectionStart = clean(eventValue.substr(0, input.selectionStart)); // trying to find cursor position in formatted value having knowledge about valueBeforeSelectionStart\n      // This works because we assume that format doesn't change the order of accepted symbols.\n      // Imagine we have formatter which adds ' symbol between numbers, and by default we refuse all non numeric symbols\n      // for example we had input = 1'2|'4 (| means cursor position) then user entered '3' symbol\n      // inputValue = 1'23'|4 so valueBeforeSelectionStart = 123 and formatted value = 1'2'3'4\n      // calling getCursorPosition(\"1'2'3'4\") will give us position after 3, 1'2'3|'4\n      // so for formatting just this function to determine cursor position after formatting is enough\n      // with masking we need to do some additional checks see `mask` below\n\n      var getCursorPosition = function getCursorPosition(val) {\n        var start = 0;\n        var cleanPos = 0;\n\n        for (var i = 0; i !== valueBeforeSelectionStart.length; ++i) {\n          var newPos = val.indexOf(valueBeforeSelectionStart[i], start) + 1;\n          var newCleanPos = clean(val).indexOf(valueBeforeSelectionStart[i], cleanPos) + 1; // this skips position change if accepted symbols order was broken\n          // For example fixes edge case with fixed point numbers:\n          // You have '0|.00', then press 1, it becomes 01|.00 and after format 1.00, this breaks our assumption\n          // that order of accepted symbols is not changed after format,\n          // so here we don't update start position if other accepted symbols was inbetween current and new position\n\n          if (newCleanPos - cleanPos > 1) {\n            newPos = start;\n            newCleanPos = cleanPos;\n          }\n\n          cleanPos = Math.max(newCleanPos, cleanPos);\n          start = Math.max(start, newPos);\n        }\n\n        return start;\n      }; // Masking part, for masks if size of mask is above some value\n      // we need to replace symbols instead of do nothing as like in format\n\n\n      if (props.mask === true && isSizeIncreaseOperation && !isNoOperation) {\n        var start = getCursorPosition(eventValue);\n        var c = clean(eventValue.substr(start))[0];\n        start = eventValue.indexOf(c, start);\n        eventValue = \"\".concat(eventValue.substr(0, start)).concat(eventValue.substr(start + 1));\n      }\n\n      var formattedValue = props.format(eventValue);\n\n      if (append != null && // cursor at the end\n      input.selectionStart === eventValue.length && !isNoOperation) {\n        if (isSizeIncreaseOperation) {\n          formattedValue = append(formattedValue);\n        } else {\n          // If after delete last char is special character and we use append\n          // delete it too\n          // was: \"12-3|\" backspace pressed, then should be \"12|\"\n          if (clean(formattedValue.slice(-1)) === '') {\n            formattedValue = formattedValue.slice(0, -1);\n          }\n        }\n      }\n\n      var replacedValue = replace ? replace(formattedValue) : formattedValue;\n\n      if (userValue === replacedValue) {\n        // if nothing changed for formatted value, just refresh so userValue will be used at render\n        refresh();\n      } else {\n        props.onChange(replacedValue);\n      }\n\n      return function () {\n        var start = getCursorPosition(formattedValue); // Visually improves working with masked values,\n        // like cursor jumping over refused symbols\n        // as an example date mask: was \"5|1-24-3\" then user pressed \"6\"\n        // it becomes \"56-|12-43\" with this code, and \"56|-12-43\" without\n\n        if (props.mask != null && (isSizeIncreaseOperation || isDeleleteButtonDown && !deleteWasNoOp)) {\n          while (formattedValue[start] && clean(formattedValue[start]) === '') {\n            start += 1;\n          }\n        }\n\n        input.selectionStart = input.selectionEnd = start + (deleteWasNoOp ? 1 + charsToSkipAfterDelete : 0);\n      };\n    });\n  }\n\n  useEffect(function () {\n    // until https://developer.mozilla.org/en-US/docs/Web/API/InputEvent/inputType will be supported\n    // by all major browsers (now supported by: +chrome, +safari, ?edge, !firefox)\n    // there is no way I found to distinguish in onChange\n    // backspace or delete was called in some situations\n    // firefox track https://bugzilla.mozilla.org/show_bug.cgi?id=1447239\n    var handleKeyDown = function handleKeyDown(evt) {\n      if (evt.code === 'Delete') {\n        isDeleleteButtonDownRef.current = true;\n      }\n    };\n\n    var handleKeyUp = function handleKeyUp(evt) {\n      if (evt.code === 'Delete') {\n        isDeleleteButtonDownRef.current = false;\n      }\n    };\n\n    document.addEventListener('keydown', handleKeyDown);\n    document.addEventListener('keyup', handleKeyUp);\n    return function () {\n      document.removeEventListener('keydown', handleKeyDown);\n      document.removeEventListener('keyup', handleKeyUp);\n    };\n  }, []);\n  return {\n    value: valueRef.current != null ? valueRef.current[0] : userValue,\n    onChange: onChange\n  };\n};\n\nvar Rifm = function Rifm(props) {\n  var renderProps = useRifm(props);\n  return props.children(renderProps);\n};\n\nexport { Rifm, useRifm };","map":{"version":3,"sources":["/home/ductran/guide-rest-client-reactjs/start/src/main/frontend/node_modules/rifm/dist/rifm.esm.js"],"names":["useReducer","useRef","useLayoutEffect","useEffect","useRifm","props","c","refresh","valueRef","replace","append","userValue","format","value","isDeleleteButtonDownRef","onChange","evt","process","env","NODE_ENV","target","type","console","error","eventValue","current","length","formattedEventValue","toLowerCase","warn","window","input","isSizeIncreaseOperation","isDeleleteButtonDown","isNoOperation","deleteWasNoOp","valueAfterSelectionStart","slice","selectionStart","acceptedCharIndexAfterDelete","search","accept","charsToSkipAfterDelete","clean","str","match","join","valueBeforeSelectionStart","substr","getCursorPosition","val","start","cleanPos","i","newPos","indexOf","newCleanPos","Math","max","mask","formattedValue","replacedValue","selectionEnd","handleKeyDown","code","handleKeyUp","document","addEventListener","removeEventListener","Rifm","renderProps","children"],"mappings":"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","sourcesContent":["import { useReducer, useRef, useLayoutEffect, useEffect } from 'react';\n\nconst useRifm = props => {\n  const [, refresh] = useReducer(c => c + 1, 0);\n  const valueRef = useRef(null);\n  const {\n    replace,\n    append\n  } = props;\n  const userValue = replace ? replace(props.format(props.value)) : props.format(props.value); // state of delete button see comments below about inputType support\n\n  const isDeleleteButtonDownRef = useRef(false);\n\n  const onChange = evt => {\n    if (process.env.NODE_ENV !== 'production') {\n      if (evt.target.type === 'number') {\n        console.error('Rifm does not support input type=number, use type=tel instead.');\n        return;\n      }\n\n      if (evt.target.type === 'date') {\n        console.error('Rifm does not support input type=date.');\n        return;\n      }\n    }\n\n    const eventValue = evt.target.value;\n    valueRef.current = [eventValue, // eventValue\n    evt.target, // input\n    eventValue.length > userValue.length, // isSizeIncreaseOperation\n    isDeleleteButtonDownRef.current, // isDeleleteButtonDown\n    userValue === props.format(eventValue) // isNoOperation\n    ];\n\n    if (process.env.NODE_ENV !== 'production') {\n      const formattedEventValue = props.format(eventValue);\n\n      if (eventValue !== formattedEventValue && eventValue.toLowerCase() === formattedEventValue.toLowerCase()) {\n        console.warn('Case enforcement does not work with format. Please use replace={value => value.toLowerCase()} instead');\n      }\n    } // The main trick is to update underlying input with non formatted value (= eventValue)\n    // that allows us to calculate right cursor position after formatting (see getCursorPosition)\n    // then we format new value and call props.onChange with masked/formatted value\n    // and finally we are able to set cursor position into right place\n\n\n    refresh();\n  }; // React prints warn on server in non production mode about useLayoutEffect usage\n  // in both cases it's noop\n\n\n  if (process.env.NODE_ENV === 'production' || typeof window !== 'undefined') {\n    useLayoutEffect(() => {\n      if (valueRef.current == null) return;\n      let [eventValue, input, isSizeIncreaseOperation, isDeleleteButtonDown, // No operation means that value itself hasn't been changed, BTW cursor, selection etc can be changed\n      isNoOperation] = valueRef.current;\n      valueRef.current = null; // this usually occurs on deleting special symbols like ' here 123'123.00\n      // in case of isDeleleteButtonDown cursor should move differently vs backspace\n\n      const deleteWasNoOp = isDeleleteButtonDown && isNoOperation;\n      const valueAfterSelectionStart = eventValue.slice(input.selectionStart);\n      const acceptedCharIndexAfterDelete = valueAfterSelectionStart.search(props.accept || /\\d/g);\n      const charsToSkipAfterDelete = acceptedCharIndexAfterDelete !== -1 ? acceptedCharIndexAfterDelete : 0; // Create string from only accepted symbols\n\n      const clean = str => (str.match(props.accept || /\\d/g) || []).join('');\n\n      const valueBeforeSelectionStart = clean(eventValue.substr(0, input.selectionStart)); // trying to find cursor position in formatted value having knowledge about valueBeforeSelectionStart\n      // This works because we assume that format doesn't change the order of accepted symbols.\n      // Imagine we have formatter which adds ' symbol between numbers, and by default we refuse all non numeric symbols\n      // for example we had input = 1'2|'4 (| means cursor position) then user entered '3' symbol\n      // inputValue = 1'23'|4 so valueBeforeSelectionStart = 123 and formatted value = 1'2'3'4\n      // calling getCursorPosition(\"1'2'3'4\") will give us position after 3, 1'2'3|'4\n      // so for formatting just this function to determine cursor position after formatting is enough\n      // with masking we need to do some additional checks see `mask` below\n\n      const getCursorPosition = val => {\n        let start = 0;\n        let cleanPos = 0;\n\n        for (let i = 0; i !== valueBeforeSelectionStart.length; ++i) {\n          let newPos = val.indexOf(valueBeforeSelectionStart[i], start) + 1;\n          let newCleanPos = clean(val).indexOf(valueBeforeSelectionStart[i], cleanPos) + 1; // this skips position change if accepted symbols order was broken\n          // For example fixes edge case with fixed point numbers:\n          // You have '0|.00', then press 1, it becomes 01|.00 and after format 1.00, this breaks our assumption\n          // that order of accepted symbols is not changed after format,\n          // so here we don't update start position if other accepted symbols was inbetween current and new position\n\n          if (newCleanPos - cleanPos > 1) {\n            newPos = start;\n            newCleanPos = cleanPos;\n          }\n\n          cleanPos = Math.max(newCleanPos, cleanPos);\n          start = Math.max(start, newPos);\n        }\n\n        return start;\n      }; // Masking part, for masks if size of mask is above some value\n      // we need to replace symbols instead of do nothing as like in format\n\n\n      if (props.mask === true && isSizeIncreaseOperation && !isNoOperation) {\n        let start = getCursorPosition(eventValue);\n        const c = clean(eventValue.substr(start))[0];\n        start = eventValue.indexOf(c, start);\n        eventValue = `${eventValue.substr(0, start)}${eventValue.substr(start + 1)}`;\n      }\n\n      let formattedValue = props.format(eventValue);\n\n      if (append != null && // cursor at the end\n      input.selectionStart === eventValue.length && !isNoOperation) {\n        if (isSizeIncreaseOperation) {\n          formattedValue = append(formattedValue);\n        } else {\n          // If after delete last char is special character and we use append\n          // delete it too\n          // was: \"12-3|\" backspace pressed, then should be \"12|\"\n          if (clean(formattedValue.slice(-1)) === '') {\n            formattedValue = formattedValue.slice(0, -1);\n          }\n        }\n      }\n\n      const replacedValue = replace ? replace(formattedValue) : formattedValue;\n\n      if (userValue === replacedValue) {\n        // if nothing changed for formatted value, just refresh so userValue will be used at render\n        refresh();\n      } else {\n        props.onChange(replacedValue);\n      }\n\n      return () => {\n        let start = getCursorPosition(formattedValue); // Visually improves working with masked values,\n        // like cursor jumping over refused symbols\n        // as an example date mask: was \"5|1-24-3\" then user pressed \"6\"\n        // it becomes \"56-|12-43\" with this code, and \"56|-12-43\" without\n\n        if (props.mask != null && (isSizeIncreaseOperation || isDeleleteButtonDown && !deleteWasNoOp)) {\n          while (formattedValue[start] && clean(formattedValue[start]) === '') {\n            start += 1;\n          }\n        }\n\n        input.selectionStart = input.selectionEnd = start + (deleteWasNoOp ? 1 + charsToSkipAfterDelete : 0);\n      };\n    });\n  }\n\n  useEffect(() => {\n    // until https://developer.mozilla.org/en-US/docs/Web/API/InputEvent/inputType will be supported\n    // by all major browsers (now supported by: +chrome, +safari, ?edge, !firefox)\n    // there is no way I found to distinguish in onChange\n    // backspace or delete was called in some situations\n    // firefox track https://bugzilla.mozilla.org/show_bug.cgi?id=1447239\n    const handleKeyDown = evt => {\n      if (evt.code === 'Delete') {\n        isDeleleteButtonDownRef.current = true;\n      }\n    };\n\n    const handleKeyUp = evt => {\n      if (evt.code === 'Delete') {\n        isDeleleteButtonDownRef.current = false;\n      }\n    };\n\n    document.addEventListener('keydown', handleKeyDown);\n    document.addEventListener('keyup', handleKeyUp);\n    return () => {\n      document.removeEventListener('keydown', handleKeyDown);\n      document.removeEventListener('keyup', handleKeyUp);\n    };\n  }, []);\n  return {\n    value: valueRef.current != null ? valueRef.current[0] : userValue,\n    onChange\n  };\n};\nconst Rifm = props => {\n  const renderProps = useRifm(props);\n  return props.children(renderProps);\n};\n\nexport { Rifm, useRifm };\n"]},"metadata":{},"sourceType":"module"}