{"ast":null,"code":"export function getTextFieldAriaText(rawValue, utils) {\n  // TODO: should `isValid` narrow `TDate | null` to `NonNullable<TDate>`?\n  // Either we allow `TDate | null` to be valid and guard against calling `formatByString` with `null`.\n  // Or we ensure `formatByString` is callable with `null`.\n  return rawValue && utils.isValid(utils.date(rawValue)) ? \"Choose date, selected date is \".concat(utils.format(utils.date(rawValue), 'fullDate')) : 'Choose date';\n}\nexport var getDisplayDate = function getDisplayDate(utils, value, inputFormat) {\n  var date = utils.date(value);\n  var isEmpty = value === null;\n\n  if (isEmpty) {\n    return '';\n  }\n\n  return utils.isValid(date) ? utils.formatByString( // TODO: should `isValid` narrow `TDate | null` to `NonNullable<TDate>`?\n  // Either we allow `TDate | null` to be valid and guard against calling `formatByString` with `null`.\n  // Or we ensure `formatByString` is callable with `null`.\n  date, inputFormat) : '';\n};\nexport function pick12hOr24hFormat(userFormat, ampm, formats) {\n  if (userFormat) {\n    return userFormat;\n  }\n\n  if (typeof ampm === 'undefined') {\n    return formats.localized;\n  }\n\n  return ampm ? formats['12h'] : formats['24h'];\n}\nvar MASK_USER_INPUT_SYMBOL = '_';\nvar staticDateWith2DigitTokens = '2019-11-21T22:30:00.000';\nvar staticDateWith1DigitTokens = '2019-01-01T09:00:00.000';\nexport function checkMaskIsValidForCurrentFormat(mask, format, acceptRegex, utils) {\n  var formattedDateWith1Digit = utils.formatByString(utils.date(staticDateWith1DigitTokens), format);\n  var inferredFormatPatternWith1Digits = formattedDateWith1Digit.replace(acceptRegex, MASK_USER_INPUT_SYMBOL);\n  var inferredFormatPatternWith2Digits = utils.formatByString(utils.date(staticDateWith2DigitTokens), format).replace(acceptRegex, '_');\n  var isMaskValid = inferredFormatPatternWith2Digits === mask && inferredFormatPatternWith1Digits === mask;\n\n  if (!isMaskValid && utils.lib !== 'luxon' && process.env.NODE_ENV !== 'production') {\n    console.warn(\"The mask \\\"\".concat(mask, \"\\\" you passed is not valid for the format used \").concat(format, \". Falling down to uncontrolled not-masked input.\"));\n  }\n\n  return isMaskValid;\n}\nexport var maskedDateFormatter = function maskedDateFormatter(mask, acceptRegexp) {\n  return function (value) {\n    return value.split('').map(function (char, i) {\n      acceptRegexp.lastIndex = 0;\n\n      if (i > mask.length - 1) {\n        return '';\n      }\n\n      var maskChar = mask[i];\n      var nextMaskChar = mask[i + 1];\n      var acceptedChar = acceptRegexp.test(char) ? char : '';\n      var formattedChar = maskChar === MASK_USER_INPUT_SYMBOL ? acceptedChar : maskChar + acceptedChar;\n\n      if (i === value.length - 1 && nextMaskChar && nextMaskChar !== MASK_USER_INPUT_SYMBOL) {\n        // when cursor at the end of mask part (e.g. month) prerender next symbol \"21\" -> \"21/\"\n        return formattedChar ? formattedChar + nextMaskChar : '';\n      }\n\n      return formattedChar;\n    }).join('');\n  };\n};","map":{"version":3,"sources":["/media/ductran/New Volume/Files/builds/quiz-maker-master/Frontend/src/main/frontend/node_modules/@mui/lab/internal/pickers/text-field-helper.js"],"names":["getTextFieldAriaText","rawValue","utils","isValid","date","format","getDisplayDate","value","inputFormat","isEmpty","formatByString","pick12hOr24hFormat","userFormat","ampm","formats","localized","MASK_USER_INPUT_SYMBOL","staticDateWith2DigitTokens","staticDateWith1DigitTokens","checkMaskIsValidForCurrentFormat","mask","acceptRegex","formattedDateWith1Digit","inferredFormatPatternWith1Digits","replace","inferredFormatPatternWith2Digits","isMaskValid","lib","process","env","NODE_ENV","console","warn","maskedDateFormatter","acceptRegexp","split","map","char","i","lastIndex","length","maskChar","nextMaskChar","acceptedChar","test","formattedChar","join"],"mappings":"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","sourcesContent":["export function getTextFieldAriaText(rawValue, utils) {\n  // TODO: should `isValid` narrow `TDate | null` to `NonNullable<TDate>`?\n  // Either we allow `TDate | null` to be valid and guard against calling `formatByString` with `null`.\n  // Or we ensure `formatByString` is callable with `null`.\n  return rawValue && utils.isValid(utils.date(rawValue)) ? `Choose date, selected date is ${utils.format(utils.date(rawValue), 'fullDate')}` : 'Choose date';\n}\nexport const getDisplayDate = (utils, value, inputFormat) => {\n  const date = utils.date(value);\n  const isEmpty = value === null;\n\n  if (isEmpty) {\n    return '';\n  }\n\n  return utils.isValid(date) ? utils.formatByString( // TODO: should `isValid` narrow `TDate | null` to `NonNullable<TDate>`?\n  // Either we allow `TDate | null` to be valid and guard against calling `formatByString` with `null`.\n  // Or we ensure `formatByString` is callable with `null`.\n  date, inputFormat) : '';\n};\nexport function pick12hOr24hFormat(userFormat, ampm, formats) {\n  if (userFormat) {\n    return userFormat;\n  }\n\n  if (typeof ampm === 'undefined') {\n    return formats.localized;\n  }\n\n  return ampm ? formats['12h'] : formats['24h'];\n}\nconst MASK_USER_INPUT_SYMBOL = '_';\nconst staticDateWith2DigitTokens = '2019-11-21T22:30:00.000';\nconst staticDateWith1DigitTokens = '2019-01-01T09:00:00.000';\nexport function checkMaskIsValidForCurrentFormat(mask, format, acceptRegex, utils) {\n  const formattedDateWith1Digit = utils.formatByString(utils.date(staticDateWith1DigitTokens), format);\n  const inferredFormatPatternWith1Digits = formattedDateWith1Digit.replace(acceptRegex, MASK_USER_INPUT_SYMBOL);\n  const inferredFormatPatternWith2Digits = utils.formatByString(utils.date(staticDateWith2DigitTokens), format).replace(acceptRegex, '_');\n  const isMaskValid = inferredFormatPatternWith2Digits === mask && inferredFormatPatternWith1Digits === mask;\n\n  if (!isMaskValid && utils.lib !== 'luxon' && process.env.NODE_ENV !== 'production') {\n    console.warn(`The mask \"${mask}\" you passed is not valid for the format used ${format}. Falling down to uncontrolled not-masked input.`);\n  }\n\n  return isMaskValid;\n}\nexport const maskedDateFormatter = (mask, acceptRegexp) => value => {\n  return value.split('').map((char, i) => {\n    acceptRegexp.lastIndex = 0;\n\n    if (i > mask.length - 1) {\n      return '';\n    }\n\n    const maskChar = mask[i];\n    const nextMaskChar = mask[i + 1];\n    const acceptedChar = acceptRegexp.test(char) ? char : '';\n    const formattedChar = maskChar === MASK_USER_INPUT_SYMBOL ? acceptedChar : maskChar + acceptedChar;\n\n    if (i === value.length - 1 && nextMaskChar && nextMaskChar !== MASK_USER_INPUT_SYMBOL) {\n      // when cursor at the end of mask part (e.g. month) prerender next symbol \"21\" -> \"21/\"\n      return formattedChar ? formattedChar + nextMaskChar : '';\n    }\n\n    return formattedChar;\n  }).join('');\n};"]},"metadata":{},"sourceType":"module"}